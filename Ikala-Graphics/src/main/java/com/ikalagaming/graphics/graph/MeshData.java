package com.ikalagaming.graphics.graph;

import com.ikalagaming.graphics.frontend.Buffer;
import com.ikalagaming.graphics.frontend.BufferUtil;

import lombok.Getter;
import lombok.Setter;
import org.joml.Vector3f;

/** Raw mesh data that is loaded from a file, after some processing. */
@Getter
public class MeshData {

    /**
     * The maximum number of bone boneWeights that can affect a vertex, the default value used by
     * Assimp when limiting bone boneWeights.
     */
    public static final int MAX_WEIGHTS = 4;

    /** The number of floats stored per vertex, in the vertex data. */
    public static final int VERTEX_SIZE_IN_FLOATS =
            3 /* position */
                    + 3 /* normal */
                    + 3 /* tangent */
                    + 3 /* bitangent */
                    + 2 /* texture coordinates */;

    /** The number of bytes stored per vertex, in the vertex data. */
    public static final int VERTEX_SIZE_IN_BYTES = VERTEX_SIZE_IN_FLOATS * Float.BYTES;

    /**
     * The maximum value (corner) of the axis-aligned bounding box that is generated by Assimp.
     *
     * @return The max value of the AABB.
     */
    private Vector3f aabbMax;

    /**
     * The minimum value (corner) of the axis-aligned bounding box that is generated by Assimp.
     *
     * @return The min value of the AABB.
     */
    private Vector3f aabbMin;

    /**
     * For each vertex, a list of bone indices and corresponding weights (interleaved, in that
     * order) that affect the vertex. Each vertex has {@link MeshData#MAX_WEIGHTS} entries in the
     * list, and if there are less than that number of bones affecting the vertex, the remaining
     * positions are filled with zeroes.
     */
    private byte[] boneWeightData;

    /** The number of bones in the mesh. */
    private int boneCount;

    /**
     * The indices of all the faces.
     *
     * @return The indices.
     */
    private int[] indices;

    /**
     * A mesh uses only a single material, so if an imported model uses multiple materials, the
     * import splits up the mesh. This value is used to index into the scene's material list.
     *
     * @param materialIndex The index to use.
     * @return The material index.
     */
    @Setter private int materialIndex;

    /**
     * Vec3 position, Vec3 normal, Vec3 tangent (positive X in the texture axis), Vec3 bitangent
     * (positive Y in the texture axis), in that order.
     */
    private float[] vertexData;

    /**
     * The number of vertices in the mesh. We store vertices as raw data so this is stored
     * separately for convenience.
     */
    private int vertexCount;

    /** The buffer (UBO) we use to store the bone weight data. */
    @Setter private Buffer boneWeightBuffer;

    /** The buffer (UBO) we store vertex data in. */
    private final Buffer vertexBuffer;

    /** The buffer (SSBO) we store post-animation values in. */
    @Setter private Buffer animationTargetBuffer;

    /** The buffer to store index data in. */
    private final Buffer indexBuffer;

    /** Used to store indirect draw commands. */
    private final Buffer drawIndirectBuffer;

    /**
     * @param aabbMin The minimum value (corner) of the axis-aligned bounding box.
     * @param aabbMax The maximum value (corner) of the axis-aligned bounding box.
     * @param vertexCount The number of vertices.
     * @param vertexData The vertex data.
     * @param indices The indices of all the faces.
     * @param boneCount The number of bones in the mesh, 0 if it is not animated.
     * @param boneWeightData The bone weight data.
     * @see #vertexData
     * @see #boneWeightData
     */
    public MeshData(
            Vector3f aabbMin,
            Vector3f aabbMax,
            int vertexCount,
            float[] vertexData,
            int[] indices,
            int boneCount,
            byte[] boneWeightData) {
        materialIndex = 0;
        this.aabbMin = aabbMin;
        this.aabbMax = aabbMax;
        this.vertexCount = vertexCount;
        this.vertexData = vertexData;
        this.indices = indices;
        this.boneCount = boneCount;
        this.boneWeightData = boneWeightData;
        this.boneWeightBuffer = null;
        this.vertexBuffer = BufferUtil.INSTANCE.createBuffer(Buffer.Type.UNIFORM);
        this.animationTargetBuffer = null;
        this.indexBuffer = BufferUtil.INSTANCE.createBuffer(Buffer.Type.INDEXES);
        this.drawIndirectBuffer = BufferUtil.INSTANCE.createBuffer(Buffer.Type.DRAW_INDIRECT);
    }
}
