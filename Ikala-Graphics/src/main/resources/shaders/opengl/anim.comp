#version 460

const int MAX_WEIGHTS = 4;

layout(std430, binding = 0) readonly buffer ModelData {
    float modelData[];
};

layout(std430, binding = 1) readonly buffer WeightData {
    float boneWeightData[];
};

layout(std430, binding = 2) readonly buffer BoneData {
    mat4 animationData[];
};

layout(std430, binding = 3) buffer AnimationTarget {
    float animationTarget[];
};

layout(std430, binding = 4) readonly buffer AnimationOffsets {
    int animationOffsets[];
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

vec4 applyTransforms(vec4 value, float transforms[MAX_WEIGHTS]) {
    vec4 result = vec4(0);
    for (i = 0; i < MAX_WEIGHTS; ++i) {
        result += transforms[i] * value;
    }
    return result;
}

void main()
{
    const int baseIdxVertex = int(gl_GlobalInvocationID.x) * 14;
    const int baseIdxWeights = int(gl_GlobalInvocationID.x) * 8;
    const int baseIdxAnimation = int(gl_GlobalInvocationID.y);
    const float animationOffset = animationOffsets[baseIdxAnimation];

    int currentIndex = baseIdxVertex;
    float animationTransforms[MAX_WEIGHTS];

    for (i = 0; i < MAX_WEIGHTS; ++i) {
        float boneIndex = boneWeightData[baseIdxWeights + (i * 2)];
        float weight = boneWeightData[baseIdxWeights + (i * 2) + 1];

        animationTransforms[i] = weight * animationData[animationOffset + boneIndex];
    }

    vec4 position = vec4(modelData[currentIndex], modelData[currentIndex + 1], modelData[currentIndex + 2], 1);
    position = applyTransforms(position, animationTransforms);
    animationTarget[currentIndex] = position.x / position.w;
    animationTarget[currentIndex + 1] = position.y / position.w;
    animationTarget[currentIndex + 2] = position.z / position.w;

    for (int i = 0; i < 3; ++i) {
        // Normal, tangent, and bitangent respectively
        currentIndex += 3;
        vec4 value = vec4(modelData[currentIndex], modelData[currentIndex + 1], modelData[currentIndex + 2], 0);
        value = applyTransforms(value, animationTransforms);
        animationTarget[currentIndex] = value.x;
        animationTarget[currentIndex + 1] = value.y;
        animationTarget[currentIndex + 2] = value.z;
    }

    currentIndex += 3;
    animationTarget[currentIndex] = modelData[currentIndex];
    animationTarget[currentIndex + 1] = modelData[currentIndex + 1];
}